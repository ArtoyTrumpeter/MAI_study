Blelloch scan(скам): префиксная сумма
В каждом i-ом элементе записана сумма элементов до i
Включающий скан и исключающий скан. i элемент включается или нет.
a0 a1 a2 ... an
Наивный алгоритм:
b0 = a0;
for (i = 1; i < n; i++) {
    b[i] = b[i-1] + a[i];
}
Можно реализовать рекурсивно.

Reduce(редукция/свёртка): алгос применяет некоторую коммутативную операцию для всех элементов массива.
Дополнительную память не использует.
Выполняем для всех потоков одного блока и затем переносим в глобал мем.
Модификации:
1) Устранение дивергенции нитей с помощью убирания if и оператора %
2) Устраняем конфликты банков памяти с помощью обращения попарно к потокам 0-32, 1-33 ... на втором шаге 0-16, 1-17 ...
   просто перенумеровав их
3) Улучшаем первую итерацию так чтобы использовалась не половина варпа
4) Убираем синхронизацию тредов за счёт варпа

Histogram(гистограмма): подсчёт элементов подходящих под один критерий
или сколько каждого числа было в массиве
0 1 0 2 1 0 0 2 2 2 1 1 1 2 2 1 0
0:5
1:6
2:6
Использует атомарные операции: AtomicAdd но из-за этого может быть коллизия
Код станет последовательным и медленным
Реализации 
    для небольшого количества чисел -shared mem 
    для большого - global mem
Можно с помощью парадокса дней рождения оценить вероятность того,
что в гистограмме будут конфликты при выполнении атомарных операций

          32!
1 - --------------
    (32-m)! * 32^m  
m - диапазон
32 - количество потоков, которые что-то делают

Bitonic sort
Похожа на Merge sort
Она построена на битонической последовательности
Полуочиститель B(n) занимается сравнением определённых элементов и их расстановкой в определённом порядке
У них есть номер n. Полуочиститель выполняет упорядочивание элементов, которые находятся друг от друга на n/2 расстоянии.
Битоническое слияние применяется для битонической последовательности.
M(n) = B(n), B(n/2), ... , B(2)
Сложность: log(n) * log(n) * n = n * log(n)^2 / P, P - кол-во потоков

Bucket sort
Каждому карману соответствует свой диапазон чисел.
Есть массив в котором находим макс и мин элементы.
Вычисляем по ним диапазон карманов.
Если массив хороший, то элементу будет примерно поровну по всем карманам.
Затем отдельно сортируется каждый карман.
max(a[i]), min(a[i])
nb - кол-во карманов
(a[i] - min) / (max - min) = [0...1]
Ключ: int((a[i] - min) / (max - min) * nb * 0.99999) = [0...nb - 1]
Ключ это номер кармана.
Затем выполняем сортировку подсчётом и после неё эти карманы должны помещаться в shared mem, 
чтобы вызвать одно ядро с кучей блоков и чтобы каждый блок взял по карману и отсортировал его.
Введём split_size = допустим 16
nb = n / split_size