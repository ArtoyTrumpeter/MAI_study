\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage{pgfplots}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\begin{document}
\thispagestyle{empty}
\begin{center}
	\bfseries

	{\Large Московский авиационный институт\\ (национальный исследовательский университет)

	}

	\vspace{48pt}

	{\large Факультет информационных технологий и прикладной математики
	}

	\vspace{36pt}


	{\large Кафедра вычислительной математики и~программирования

	}


	\vspace{48pt}

	{Лабораторная работа №\,9 по курсу дискретного анализа: Графы}

\end{center}

\vspace{72pt}

\begin{flushright}
	\begin{tabular}{rl}
		Студент:       & А.\, О. Тояков   \\
		Преподаватель: & А.\, Н. Ридли \\
		Группа:        & М8О-307Б-18      \\
		Дата:          &                 \\
		Оценка:        &                  \\
		Подпись:       &                  \\
	\end{tabular}
\end{flushright}

\vfill

\begin{center}
	\bfseries
	Москва\\
	\the\year
\end{center}

\newpage

\subsection*{Условие}

Разработать программу на языке C или C++, реализующую указанный алгоритм согласно заданию:

Задан неориентированный граф, состоящий из n вершин и m ребер. Вершины пронумерованы целыми числами от 1 до n. Необходимо вывести все компоненты связности данного графа.

Каждую компоненту связности нужно выводить в отдельной строке, в виде списка номеров вершин через пробел. Строки при выводе должны быть отсортированы по минимальному номеру вершины в компоненте, числа в одной строке также должны быть отсортированы.

\subsection*{Метод решения}

Для решения этой задачи нужно будет реализовать поиск в глубину. Граф будем представлять в виде пар смежных вершин. Будем проходить по всем вершинам и добавлять их в ответ, если они ещё не были пройдены (так называемые белые вершины; после добавления сразу же перекрашиваем их в серый или чёрный). Если же поиск зайдёт в тупик, значит все компоненты связности для определённой части графа собраны и можно переходить к следующим вершинам. 

\subsection*{Описание программы}

Для хранения вершин я создал структуру TNode, в которой хранится цвет вершины (white, если вершина ещё не пройдена и grey или black иначе), её индекс, а также вектор, состоящий из индексов связанных с ней вершин. В итоге представление графа реализовано, как вектор G <TNode>, в котором мы храним все связи в нашем графе.

Поиск осуществляется с помощью функции DFS, в которой мы создаём вектор answer, куда мы будем заносить компоненты связности и поочереди их выводить. Мы проходим по всем индексам вектора G, и если наша текущая вершина белая, то заносим её в answer и запускаем функцию DfsVisit, которая пройдёт по всем вершинам связанным с текущей и добавит их в ответ. Когда функция зайдёт в тупик мы получим нашу полную текущую компоненту связности. Затем элементы в векторе answer отсортируются с помощью std::sort и распечатаются. Так мы будем проходить по всему вектору G, пока не выведем все компоненты связности.

\subsection*{Исходный код}

\begin{verbatim}
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct TNode {
	int id;
	char color = 'w';
	vector<int> edges;
};

void DfsVisit(vector<TNode> &G, TNode &u, vector<int> &answ) {
	u.color = 'g';
	for (int i = 0; i < u.edges.size(); i++) {
		if (G[u.edges[i]].color == 'w') {
			answ.push_back(u.edges[i]);
			DfsVisit(G, G[u.edges[i]], answ);
		}
	}
	u.color = 'b';
}

void DFS(vector<TNode> &G) {
	vector<int> answ;
	for (int i = 1; i < G.size(); i++) {
		if (G[i].color == 'w') {
			answ.push_back(G[i].id);
			DfsVisit(G, G[i], answ);
			sort(answ.begin(), answ.end());
			for (int j = 0; j < answ.size(); j++) {
				cout << answ[j];
				j == answ.size() - 1 ? cout << '\n' : cout << ' ';
			}
			answ.clear();
		}
	}
	
}

int main () {
	int n, m, from, to;
	cin >> n >> m;
	vector<TNode> G(n + 1);
	for (int i = 1; i <= n; i++) {
		G[i].id = i;
	}
	for (int i = 0; i < m; i++) {
		cin >> from >> to;	
		G[from].edges.push_back(to);
		G[to].edges.push_back(from);
	}
	DFS(G);
	return 0;
}
\end{verbatim}

\subsection*{Тест производительности}

Тесты представляют из себя файлы, в которых сгенерировано различное число отрезков m. Количество вершин получаем рандомно, но оно не превосходит введённой число n.

\begin{tikzpicture}
\begin{axis}
\addplot coordinates {
( 10000, 0.0075)
( 50000, 0.036)
( 100000, 0.092)
( 200000, 0.2)};
\end{axis}
\end{tikzpicture}
\newline
Пояснения к графику:
Ось y - время в секундах. Ocь x - количество отрезков.

\subsection*{Выводы}

Реализовать поиск в глубину было довольно просто. Этот алгоритм имеет много приложений помимо поиска компонент связности, например, он может использоваться в топологической сортировке. В целом теория графов помогает нам решать задачи, связанные с логистикой и различными передвижениями, но также она применяется в областях, не связанных с информатикой, например, в химии для описания путей сложных реакций. На сегодняшний день существует огромное количество алгоритмов и приёмов, которые используются в теории графов. Нам лишь остаётся реализовать нужный алгоритм, исходя из условий задачи.

\end{document}
